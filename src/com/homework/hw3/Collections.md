<h1> Task 1 </h1>
LinkedList внутренне использует двусвязный список для хранения элементов.

Сравнение производительности MyLinkedList и LinkedList базовой реализации Java показало:
1. вставка 1000 элементов в моей реализации уступает готовой
2. поиск 100 элементов в моей реализации работает быстрее
3. удаление 100 элементов в моей реализации работает немного быстрее 

Результаты варьируются от запуска. При среднем количестве элементов моя реализация работает быстрее готовой. 

График ниже показывает количество потраченного времени в наносекундах на каждую из операций. Количество элементов в списке - 30000.

![chart1](https://user-images.githubusercontent.com/75098356/143531067-572cd43e-5c22-4504-8689-5718446a9de1.png)

<h1> Task 2 </h1>
<h2> a. Сравнение производительности ArrayList и LinkedList для основных операций </h2>
ArrayList внутренне использует динамический массив для хранения элементов. LinkedList внутренне использует двусвязный список для хранения элементов.

![image](https://user-images.githubusercontent.com/75098356/143542762-6769d141-ca41-4a5d-a397-ea440d59afe7.png)

![image](https://user-images.githubusercontent.com/75098356/143542804-a5823027-0aad-4a4c-bb19-3305d5da6fcb.png)

Сравнение показало, что ArrayList выигрывает в операциях вставки в начало и конец, удалении из конца. LinkedList предпочтительнее использовать на операциях добавления, поиска, удаления из начала.

График ниже показывает количество потраченного времени в наносекундах на каждую из операций. Количество элементов в списке - 100000.

![chart2_1](https://user-images.githubusercontent.com/75098356/143539565-856022c7-4499-4f22-9555-cc17d340df77.png)

<h2> b. Сравнение производительности HashSet, LinkedHashSet, TreeSet для основных операций </h2>
HashSet использует HashMap внутри для хранения своих элементов, LinkedHashSet использует LinkedHashMap, a TreeSet использует TreeMap.

HashSet обеспечивает лучшую производительность, на втором месте LinkedHashSet. TreeSet дает меньшую производительность, чем HashSet и LinkedHashSet, поскольку он должен сортировать элементы после каждой операции вставки и удаления.
График ниже показывает количество потраченного времени в наносекундах на каждую из операций. Количество элементов в списке - 100000.

![chart2_2](https://user-images.githubusercontent.com/75098356/143540585-1ed622b3-6bec-4b78-b9ba-3007bff1b16b.png)

<h2> c. Сравнение производительности HashMap, LinkedHashMap, TreeMap для основных операций </h2>
Все три класса реализуют интерфейс Map и предлагают в основном одну и ту же функциональность. Наиболее важным отличием является порядок, в котором будет происходить повторение записей:

HashMap не дает абсолютно никаких гарантий относительно порядка итераций. Он может (и будет) даже полностью изменяться при добавлении новых элементов.
TreeMap будет повторяться в соответствии с "natural ordering" ключей в соответствии с их методом compareTo() (или внешне поставляемым Comparator ). Дополнительно, он реализует интерфейс SortedMap, который содержит методы, зависящие от этого порядка сортировки.
LinkedHashMap будет повторяться в том порядке, в котором записи были помещены на карту

<h1> Conclusion </h1>
1. ArrayList лучше подходит для хранения данных и доступа к ним.
2. LinkedList лучше подходит для управления данными.
3. HashSet лучше подходит, если вы не хотите поддерживать какой-либо порядок элементов.
4. LinkedHashSet лучше подходит, если хотите сохранить порядок вставки элементов.
5. TreeSet лучше подходит, если вы хотите отсортировать элементы в соответствии с некоторым компаратором.
6. 
